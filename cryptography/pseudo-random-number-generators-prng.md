---
description: >-
  Often the default random function in whatever language is not
  cryptographically secure, making it possible to predict values
---

# Pseudo-Random Number Generators (PRNG)

## Python: `import random` = Mersenne Twister

The default Python `random` module is very fast, but not very secure. If the application allows you to get 624 or more random values from it, you can crack the random seed used by the generator to predict future values. You can also use this to know values that are generated by the application, but not shown to you, like generating a key right after showing you 624 random values.&#x20;

Python has a handy library called [RandCrack](https://github.com/tna0y/Python-random-module-cracker) which can crack the seed of Python's `random` module. Just submit 624 values and then you can predict future values:&#x20;

```python
import random
from randcrack import RandCrack

rc = RandCrack()

# Fill RandCrack to get seed
for i in range(624):
	rc.submit(random.getrandbits(32))
	# Could be filled with random.randint(0,4294967294) or random.randrange(0,4294967294)

# Generate and predict 10 random values
predicted = [rc.predict_randrange(0, 1000) for _ in range(10)]
real = [random.randrange(0, 1000) for _ in range(10)]

print(f"Random result:  {predicted}")
print(f"Cracker result: {real}")
```

I made a writeup of a challenge where you had to crack the seed after 624 random values, to generate the same key as the application would encrypt the flag:

{% embed url="https://jorianwoltjer.com/blog/post/ctf/google-beginners-quest-2021/5-twisted-robot" %}
A writeup where RandCrack is used to predict future values to get a key
{% endembed %}

## JavaScript: `Math.random()` = xorshift128+

Javascript has a few variants per browser. Chrome, Firefox, and Safari all do slightly different things when it comes to generating random numbers. But Chrome uses V8 for JavaScript, and so does NodeJS. This makes it the biggest target.&#x20;

The `Math.random()` function is not cryptographically secure, and with about 5 random numbers from it, one can crack the random state and predict future values.&#x20;

[PwnFunction ](https://www.youtube.com/watch?v=-h\_rj2-HP2E)made a great video explaining the attack and published a Python script that uses the Z3 solver to solve the random state and predict future numbers.&#x20;

{% embed url="https://github.com/PwnFunction/v8-randomness-predictor/blob/main/main.py" %}
Python script that can predict V8 Math.random() after 5 inputs
{% endembed %}

```javascript
> Array.from(Array(5), Math.random)
[
  0.8971227301319089,
  0.6209246336108811,
  0.5512987330965515,
  0.4297735084849734,
  0.9373384773813349
]
// Save to 'sequence' in the Python script and run it
> Math.random()
0.446420067790525
```

## Java: `java.util.Random()` = Linear Congruential Generator

Java's random number generator uses a Linear Congruential Generator (LCG). These generators are really fast but also really insecure. The internal state is only 48 bits long and can be recovered with only a few samples. For example, it doesn't help that the `int` output values from the generator are simply the first 32 bits of the state, allowing you to brute-force the last 16 bits if you have another sample you can compare with.&#x20;

This idea is explained [here ](https://jazzy.id.au/2010/09/20/cracking\_random\_number\_generators\_part\_1.html)and implemented well for a few functions that give a lot of information:

{% embed url="https://github.com/fta2012/ReplicatedRandom" %}
A simple Java library that automates extracting and brute-forcing the state of using big numbers
{% endembed %}

### Fewer bits per sample

The above method is possible because you get a big part of the internal state in one single number (like and `int`). But in some cases, you can't get all this information, only small numbers that are generated using a range. This is where another more involved method comes in that can analyze the patterns between numbers in order to recover the internal state.&#x20;

Getting a number from the `java.util.Random()` generator works by **truncating** the state (seed) with a number of bits. If you need a 32-bit number, the first 32 bits of the seed are given and the seed rotates for the next time. If you need an 8-bit number the first 8 bits are given and the seed is rotated again. This means that using 8-bit numbers you only get a small part (top 8 bits) of the seed, and then it already rotates to the next seed. That is the problem we are trying to solve.&#x20;

It turns out this can be done using [LLL Reduction](https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz\_lattice\_basis\_reduction\_algorithm), a highly useful algorithm in cryptanalysis. The math of this all is pretty complex, but implementations already exist allowing you to use them. \
[This gist](https://gist.github.com/maple3142/c7c31d2e5893d524e71eb5e12b0278f0) has a few different methods for cracking general LCGs and can be applied to Java specifically by only changing the constants.&#x20;

I made [another gist](https://gist.github.com/JorianWoltjer/e10cf3235adfc47b1c6f6e90b8411fae) that is specific to Java's `Random()` class and has an easy-to-use CLI.&#x20;

<details>

<summary>Information</summary>

The internal seed has 48 bits, and every sample you give to the program will give some amount of bits of information. Here is a table to get an idea of how many samples you should provide per amount of bits in your input number:

It tries to recover the state from numbers generated using the Linear Congruential Generator (LCG) in Java. For example:

```java
Random random = new Random();

int sample = random.nextInt(256);  // Single 8-bit number
int[] samples = random.ints(8, 0, 256).toArray();  // 8x 8-bit numbers
```

The program is meant for situations where numbers returned from the generator are **small**, and can recover the state perfectly from only a few samples, cloning the generator and allowing you to generate future values beforehand.

**Warning**: This script currently only works for numbers generated with an upper bound of a power of 2. This means a number generated like `random.nextInt(256)` will work, but something like `random.nextInt(200)` likely won't. This is because, in the case of not having a power of 2, the LCG might generate multiple numbers per call, giving us an unknown amount of missing numbers in the samples.

### Example

```java
Random random = new Random(1337);

int[] samples = random.ints(8, 0, 256).toArray();  // Generate 8x 8-bit numbers to give the program
System.out.println(samples);  // { 168, 44, 176, 223, 226, 247, 230, 207 }

int[] secrets = random.ints(8, 0, 256).toArray();  // Generate 8 more secret numbers
System.out.println(secrets);  // { 44, 164, 241, 235, 37, 5, 81, 252 }
```

Now we will feed the `samples` into the Python program. The numbers are generated from 0-255, which is **8** bits:

<pre class="language-python"><code class="lang-python"><strong>Known bits: 8
</strong><strong>Input: 168, 44, 176, 223, 226, 247, 230, 207 
</strong>States found: [185753720734415, 48973695446062, 194004564009889, 246107133972888, 248619153362371, 272076196875794, 252907395951029, 228694819430428]
<strong>Guesses: [44, 164, 241, 235, 37, 5, 81, 252]
</strong></code></pre>

**Tip**: To get more control over what numbers are guessed after the state has been cracked, you can use the [`java-random`](https://github.com/MostAwesomeDude/java-random) library to clone the generator by setting its internal state to one of the found states, and then calling the function on it to extract the numbers you need.

</details>

<details>

<summary>Python Script (<code>truncated_java_random.py</code>)</summary>

{% code title="truncated_java_random.py" %}
```python
# Source of algorithm: https://gist.github.com/maple3142/c7c31d2e5893d524e71eb5e12b0278f0

from sage.all import *

# Constants for `java.util.Random`
BITS_TOTAL = 48
a = 0x5DEECE66D
c = 0xB

m = 2**BITS_TOTAL


class LCG:
    """Simple Linear Congruential Generator implementation"""

    def __init__(self, a, c, m, seed):
        self.a = a
        self.c = c
        self.m = m
        self.state = seed
        self.counter = 0

    def next_state(self):
        self.state = (self.a * self.state + self.c) % self.m

    def get_bits(self, n):
        return self.state >> (BITS_TOTAL - n)


def get_L(k):
    M = matrix([m])
    A = matrix([a**i for i in range(1, k)]).T
    I = matrix.identity(k - 1) * -1
    Z = matrix([0] * (k - 1))
    L = block_matrix([[M, Z], [A, I]])
    return L


def solve(truncated, bits_known):
    """Solve the truncated states in `truncated`, given `bits_known` known bits"""
    bits_unknown = BITS_TOTAL - bits_known

    K = [c]
    for i in range(1, len(truncated)):
        K.append((K[-1] + c * a**i) % m)
    K = vector(K)
    L = get_L(len(truncated))
    shifted = [(x * 2**bits_unknown - K[i]) % m for i, x in enumerate(truncated)]
    B = L.LLL()
    sys = vector(shifted)
    sby = B * sys
    ks = vector(round(x) for x in sby / m)
    zs = B.solve_right(ks * m - sby)
    tmp = sys + zs
    results = [(tmp[i] + K[i]) % m for i in range(len(tmp))]
    assert (L * vector(results)) % m == (L * K) % m  # Extra checking

    return results


def java_to_python(n):
    """Convert a Java integer to Python integer"""
    return n if n >= 0 else n + 2**32


def python_to_java(n):
    """Convert a Python integer to Java integer"""
    return n if n < 2**31 else n - 2**32


if __name__ == "__main__":
    from colorama import Fore, Style

    n_bits = int(input(f"Known bits: {Fore.LIGHTBLUE_EX}"))
    print(Style.RESET_ALL, end="")

    # Get user input
    truncated = [
        java_to_python(int(n)) for n in input(f"Input: {Fore.LIGHTGREEN_EX}").split(",")
    ]
    print(Style.RESET_ALL, end="")

    # Solve
    results = solve(truncated, n_bits)
    print(f"{Fore.LIGHTBLACK_EX}States found: {results}{Style.RESET_ALL}")

    # Create a clone
    clone = LCG(a, c, m, results[-1])

    guesses = []
    for _ in range(len(truncated)):
        clone.next_state()
        guesses.append(python_to_java(clone.get_bits(n_bits)))

    print(f"Guesses: {Fore.LIGHTRED_EX}{guesses}{Style.RESET_ALL}")
```
{% endcode %}

</details>
